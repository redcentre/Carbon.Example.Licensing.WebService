//================================================================================================
// <auto-generated>
// This code was generated by a tool on machine OWL at local time 30/05/2025 12:28:31.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//================================================================================================
using System;
using System.CodeDom.Compiler;
using System.Net.Http;
using System.Threading.Tasks;
using RCS.Azure.StorageAccount.Shared;
using RCS.Licensing.Provider.Shared;
using RCS.Licensing.Provider.Shared.Entities;

#nullable enable

namespace RCS.Licensing.Example.WebService.Shared
{
	partial interface IExampleLicensingServiceClient
	{
		// +-----------------------------------+
		// ¦   AuthenticationController        ¦
		// +-----------------------------------+
		Task<ResponseWrap<LicenceFull>> AuthenticateName(string userName, string password, bool skipCache = false);
		Task<ResponseWrap<LicenceFull>> AuthenticateId(string userId, string password, bool skipCache = false);
		Task<ResponseWrap<LicenceFull>> GetFreeLicence(string clientIdentifier, bool skipCache = false);
		// +-----------------------------------+
		// ¦   ServiceController               ¦
		// +-----------------------------------+
		Task<ResponseWrap<ServiceInfo>> GetServiceInfo();
		Task<ResponseWrap<MockResponse>> ThrowError(int number);
		// +-----------------------------------+
		// ¦   ProviderController              ¦
		// +-----------------------------------+
		Task<ResponseWrap<bool>> GetSupportsRealms();
		Task<ResponseWrap<NavData>> GetNavigationData();
		Task<ResponseWrap<ReportItem[]>> GetDatabaseReport();
		// +-----------------------------------+
		// ¦   RealmController                 ¦
		// +-----------------------------------+
		Task<ResponseWrap<Realm?>> ReadRealm(string id);
		Task<ResponseWrap<Realm[]>> ListRealms();
		Task<ResponseWrap<UpsertResult<Realm>>> UpsertRealm(Realm realm);
		Task<ResponseWrap<string[]?>> ValidateRealm(string realmId);
		Task<ResponseWrap<int>> DeleteRealm(string id);
		Task<ResponseWrap<Realm?>> DisconnectRealmChildCustomer(string realmId, string customerId);
		Task<ResponseWrap<Realm?>> ConnectRealmChildCustomers(string realmId, string[] customerIds);
		Task<ResponseWrap<Realm?>> ReplaceRealmChildCustomers(string realmId, string[] customerIds);
		Task<ResponseWrap<Realm?>> DisconnectRealmChildUser(string realmId, string userId);
		Task<ResponseWrap<Realm?>> ConnectRealmChildUsers(string realmId, string[] userIds);
		Task<ResponseWrap<Realm?>> ReplaceRealmChildUsers(string realmId, string[] userIds);
		// +-----------------------------------+
		// ¦   CustomerController              ¦
		// +-----------------------------------+
		Task<ResponseWrap<Customer[]>> ListCustomers();
		Task<ResponseWrap<Customer[]>> ListCustomers(params string[] ids);
		Task<ResponseWrap<CustomerPick[]>> ListCustomerPicksForRealms(params string[]? ids);
		Task<ResponseWrap<UpsertResult<Customer>>> UpsertCustomer(Customer customer);
		Task<ResponseWrap<string[]>> ValidateCustomer(string id);
		Task<ResponseWrap<int>> DeleteCustomer(string id);
		Task<ResponseWrap<Customer?>> ReadCustomer(string id);
		Task<ResponseWrap<Customer[]>> ReadCustomersByName(string name);
		Task<ResponseWrap<Customer?>> DisconnectCustomerChildJob(string customerId, string jobId);
		Task<ResponseWrap<Customer?>> ConnectCustomerChildJobs(string customerId, string[] jobIds);
		Task<ResponseWrap<Customer?>> ReplaceCustomerChildJobs(string customerId, string[] jobIds);
		Task<ResponseWrap<Customer?>> DisconnectCustomerChildUser(string customerId, string userId);
		Task<ResponseWrap<Customer?>> ConnectCustomerChildUsers(string customerId, string[] userIds);
		Task<ResponseWrap<Customer?>> ReplaceCustomerChildUsers(string customerId, string[] userIds);
		Task<ResponseWrap<SubscriptionAccount[]>> ListStorageAccounts();
		Task<ResponseWrap<bool?>> IsStorageAccountNameAvailable(string name);
		Task<ResponseWrap<SubscriptionAccount?>> CreateStorageAccount(string name, string resourceGroupName, string location, bool allowBlobPublicAccess);
		// +-----------------------------------+
		// ¦   JobController                   ¦
		// +-----------------------------------+
		Task<ResponseWrap<Job?>> ReadJob(string id);
		Task<ResponseWrap<Job[]>> ListJobs();
		Task<ResponseWrap<UpsertResult<Job>>> UpsertJob(Job job);
		Task<ResponseWrap<string[]>> ValidateJob(string id);
		Task<ResponseWrap<int>> DeleteJob(string id);
		Task<ResponseWrap<Job?>> DisconnectJobChildUser(string jobId, string userId);
		Task<ResponseWrap<Job?>> ConnectJobChildUsers(string jobId, string[] userIds);
		Task<ResponseWrap<Job?>> ReplaceJobChildUsers(string jobId, string[] userIds);
		Task<ResponseWrap<string>> CompareJobsAndContainers();
		Task<ResponseWrap<bool>> CreateJobContainer(string jobId, JobContainerAccessType accessType);
		// +-----------------------------------+
		// ¦   UserController                  ¦
		// +-----------------------------------+
		Task<ResponseWrap<UpsertResult<User>>> CreateUser(User user);
		Task<ResponseWrap<User?>> ReadUser(string id);
		Task<ResponseWrap<User[]>> ListUsers();
		Task<ResponseWrap<User[]>> ListUsers(params string[] ids);
		Task<ResponseWrap<UserPick[]>> ListUserPicksForRealms(params string[]? ids);
		Task<ResponseWrap<UpsertResult<User>>> UpsertUser(User user);
		Task<ResponseWrap<int>> DeleteUser(string id);
		Task<ResponseWrap<User?>> DisconnectUserChildCustomer(string userId, string customerId);
		Task<ResponseWrap<User?>> ConnectUserChildCustomers(string userId, string[] customerIds);
		Task<ResponseWrap<User?>> ReplaceUserChildCustomers(string userId, string[] customerIds);
		Task<ResponseWrap<User?>> DisconnectUserChildJob(string userId, string jobId);
		Task<ResponseWrap<User?>> ConnectUserChildJobs(string userId, string[] jobIds);
		Task<ResponseWrap<User?>> ReplaceUserChildJobs(string userId, string[] jobIds);
		Task<ResponseWrap<User?>> DisconnectUserChildRealm(string userId, string realmId);
		Task<ResponseWrap<User?>> ConnectUserChildRealms(string userId, string[] realmIds);
		Task<ResponseWrap<User?>> ReplaceUserChildRealms(string userId, string[] realmIds);
		Task<ResponseWrap<int>> PasswordChange(string userId, string oldPassword, string newPassword);
		Task<ResponseWrap<string?>> PasswordChangePlea(string userId);
		Task<ResponseWrap<PleaItem?>> GetPlea(string id);
		Task<ResponseWrap<int>> UpdateAccount(string userId, string userName, string? email, string? comment);
	}

	partial class ExampleLicensingServiceClient
	{
		// +----------------------------------+
		// ¦                                  ¦
		// ¦   AuthenticationController       ¦
		// ¦                                  ¦
		// +----------------------------------+

		/// <summary>
		///   Authenticate licensing system account Name and password credentials.
		/// </summary>
		/// <param name="userName">Account user name.</param>
		/// <include file='DocHelp.xml' path='doc/members[@name="AuthCommon"]/*'/>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<LicenceFull>> AuthenticateName(string userName, string password, bool skipCache = false)
		{
			var request = new AuthenticateNameRequest(userName, password, skipCache);
			HttpResponseMessage hrm = await Client.PostAsync("authentication/name", MakeContent(request));
			var wrap = await UnwrapAndCheckResult<LicenceFull>(hrm, throwOnError);
			InspectLicence(wrap.Data);
			return wrap;
		}

		/// <summary>
		///   Authenticate licensing system account Id and password credential 
		///   authentication.
		/// </summary>
		/// <param name="userId">Account user Id.</param>
		/// <include file='DocHelp.xml' path='doc/members[@name="AuthCommon"]/*'/>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<LicenceFull>> AuthenticateId(string userId, string password, bool skipCache = false)
		{
			var request = new AuthenticateIdRequest(userId, password, skipCache);
			HttpResponseMessage hrm = await Client.PostAsync("authentication/id", MakeContent(request));
			var wrap = await UnwrapAndCheckResult<LicenceFull>(hrm, throwOnError);
			InspectLicence(wrap.Data);
			return wrap;
		}

		/// <summary>
		///   Get a free licence that can be used for evaluations and trial periods.
		/// </summary>
		/// <remarks>
		///   This endpoint requires that the licensing database contain a valid account with 
		///   the name 'guest'. Hosts of the licensing service may choose to optionally 
		///   implement the guest account.
		/// </remarks>
		/// <param name="clientIdentifier">Client caller identifier (usually an email address).</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<LicenceFull>> GetFreeLicence(string clientIdentifier, bool skipCache = false)
		{
			var request = new FreeLicenceRequest(clientIdentifier, skipCache);
			HttpResponseMessage hrm = await Client.PostAsync("authentication/free", MakeContent(request));
			var wrap = await UnwrapAndCheckResult<LicenceFull>(hrm, throwOnError);
			InspectLicence(wrap.Data);
			return wrap;
		}

		// +----------------------------------+
		// ¦                                  ¦
		// ¦   ServiceController              ¦
		// ¦                                  ¦
		// +----------------------------------+

		/// <summary>
		///   Gets service metadata information.
		/// </summary>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<ServiceInfo>> GetServiceInfo()
		{
			HttpResponseMessage hrm = await Client.GetAsync("service/info");
			return await UnwrapAndCheckResult<ServiceInfo>(hrm, throwOnError);
		}

		/// <summary>
		///   Causes a deliberate service internal error for testing.
		/// </summary>
		/// <param name="number">Some number.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<MockResponse>> ThrowError(int number)
		{
			HttpResponseMessage hrm = await Client.GetAsync("service/throw");
			return await UnwrapAndCheckResult<MockResponse>(hrm, throwOnError);
		}

		// +----------------------------------+
		// ¦                                  ¦
		// ¦   ProviderController             ¦
		// ¦                                  ¦
		// +----------------------------------+

		/// <summary>
		///   Gets a flag indicating if the licensing service provider supports realms.
		/// </summary>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<bool>> GetSupportsRealms()
		{
			HttpResponseMessage hrm = await Client.GetAsync("provider/property/supportsrealms");
			return await UnwrapAndCheckResult<bool>(hrm, throwOnError);
		}

		/// <summary>
		///   Gets the navigation tree.
		/// </summary>
		/// <remarks>
		///   Client applications can use the returned values to build custom navigation 
		///   collections.
		/// </remarks>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<NavData>> GetNavigationData()
		{
			HttpResponseMessage hrm = await Client.GetAsync("provider/navdata");
			return await UnwrapAndCheckResult<NavData>(hrm, throwOnError);
		}

		/// <summary>
		///   Gets the database report.
		/// </summary>
		/// <remarks>
		///   Client applications can use the returned items to build custom reports.
		/// </remarks>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<ReportItem[]>> GetDatabaseReport()
		{
			HttpResponseMessage hrm = await Client.GetAsync("provider/dbreport");
			return await UnwrapAndCheckResult<ReportItem[]>(hrm, throwOnError);
		}

		// +----------------------------------+
		// ¦                                  ¦
		// ¦   RealmController                ¦
		// ¦                                  ¦
		// +----------------------------------+

		/// <summary>
		///   Reads a realm by Id.
		/// </summary>
		/// <remarks>
		///   The response <c>hasError</c> property will be true if the realm is not found.
		/// </remarks>
		/// <param name="id">The Id of the realm to read.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm?>> ReadRealm(string id)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"realm/read/{id}");
			return await UnwrapAndCheckResult<Realm?>(hrm, throwOnError);
		}

		/// <summary>
		///   Lists all realms.
		/// </summary>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm[]>> ListRealms()
		{
			HttpResponseMessage hrm = await Client.GetAsync("realm/list");
			return await UnwrapAndCheckResult<Realm[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Updates or inserts a customer.
		/// </summary>
		/// <remarks>
		///   If the <c>Id</c> property is null then a new realm record is created, otherwise 
		///   an existing realm with the Id is updated. The following properties are ignored: 
		///   <c>Created</c>, <c>Customers</c>, <c>Users</c>.
		/// </remarks>
		/// <param name="realm">The Realm containing the values to update.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<UpsertResult<Realm>>> UpsertRealm(Realm realm)
		{
			HttpResponseMessage hrm = await Client.PutAsync("realm/", MakeContent(realm));
			return await UnwrapAndCheckResult<UpsertResult<Realm>>(hrm, throwOnError);
		}

		/// <summary>
		///   Validates the properties of a realm.
		/// </summary>
		/// <param name="realmId">The Id of the parent realm to validate.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<string[]?>> ValidateRealm(string realmId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"realm/validate/{realmId}");
			return await UnwrapAndCheckResult<string[]?>(hrm, throwOnError);
		}

		/// <summary>
		///   Deletes a realm by Id.
		/// </summary>
		/// <remarks>
		///   The response integer is the number of licensing database rows affected by 
		///   delete processing. Zero indicates that the realm was not found.
		/// </remarks>
		/// <param name="id">The Id of the realm to delete.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<int>> DeleteRealm(string id)
		{
			HttpResponseMessage hrm = await Client.DeleteAsync($"realm/{id}");
			return await UnwrapAndCheckResult<int>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a realm from a customer.
		/// </summary>
		/// <param name="realmId">The Id of the parent realm.</param>
		/// <param name="customerId">The Id of the child customer.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm?>> DisconnectRealmChildCustomer(string realmId, string customerId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"realm/disconnect/{realmId}/customer/{customerId}");
			return await UnwrapAndCheckResult<Realm?>(hrm, throwOnError);
		}

		/// <summary>
		///   Connects a realm to customers.
		/// </summary>
		/// <param name="realmId">The parent realm Id.</param>
		/// <param name="customerIds">The child customer Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm?>> ConnectRealmChildCustomers(string realmId, string[] customerIds)
		{
			var request = new JoinsRequest(realmId, customerIds);
			HttpResponseMessage hrm = await Client.PostAsync("realm/connect/customers", MakeContent(request));
			return await UnwrapAndCheckResult<Realm?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces the joins between a realm and customers.
		/// </summary>
		/// <param name="realmId">The parent realm Id.</param>
		/// <param name="customerIds">The child customer Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm?>> ReplaceRealmChildCustomers(string realmId, string[] customerIds)
		{
			var request = new JoinsRequest(realmId, customerIds);
			HttpResponseMessage hrm = await Client.PostAsync("realm/replace/customers", MakeContent(request));
			return await UnwrapAndCheckResult<Realm?>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a realm from a user.
		/// </summary>
		/// <param name="realmId">The Id of the parent realm.</param>
		/// <param name="userId">The Id of the child user.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm?>> DisconnectRealmChildUser(string realmId, string userId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"realm/disconnect/{realmId}/user/{userId}");
			return await UnwrapAndCheckResult<Realm?>(hrm, throwOnError);
		}

		/// <summary>
		///   Connects a realm to users.
		/// </summary>
		/// <param name="realmId">The parent realm Id.</param>
		/// <param name="userIds">The child user Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm?>> ConnectRealmChildUsers(string realmId, string[] userIds)
		{
			var request = new JoinsRequest(realmId, userIds);
			HttpResponseMessage hrm = await Client.PostAsync("realm/connect/users", MakeContent(request));
			return await UnwrapAndCheckResult<Realm?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces the joins between a realm and users.
		/// </summary>
		/// <param name="realmId">The parent realm Id.</param>
		/// <param name="userIds">The child user Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Realm?>> ReplaceRealmChildUsers(string realmId, string[] userIds)
		{
			var request = new JoinsRequest(realmId, userIds);
			HttpResponseMessage hrm = await Client.PostAsync("realm/replace/users", MakeContent(request));
			return await UnwrapAndCheckResult<Realm?>(hrm, throwOnError);
		}

		// +----------------------------------+
		// ¦                                  ¦
		// ¦   CustomerController             ¦
		// ¦                                  ¦
		// +----------------------------------+

		/// <summary>
		///   Lists all customers.
		/// </summary>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer[]>> ListCustomers()
		{
			HttpResponseMessage hrm = await Client.GetAsync("customer/list");
			return await UnwrapAndCheckResult<Customer[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Gets a summary list of customers filtered by realm.
		/// </summary>
		/// <param name="ids">The realm Ids to filter the customer list response.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer[]>> ListCustomers(params string[] ids)
		{
			var request = new IdFilterRequest(ids);
			HttpResponseMessage hrm = await Client.PostAsync("customer/list", MakeContent(request));
			return await UnwrapAndCheckResult<Customer[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Gets a summary pick list of all customers filterd by realm Id.
		/// </summary>
		/// <remarks>
		///   The returned array of lightweight <c>CustomerPick</c> objects can be used by 
		///   clients to fill summary or pick lists of customers.
		/// </remarks>
		/// <param name="ids">An array of realm ids to filter customer pick list response.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<CustomerPick[]>> ListCustomerPicksForRealms(params string[]? ids)
		{
			var request = new IdFilterRequest(ids);
			HttpResponseMessage hrm = await Client.PostAsync("customer/list/picks", MakeContent(request));
			return await UnwrapAndCheckResult<CustomerPick[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Updates or inserts a customer.
		/// </summary>
		/// <remarks>
		///   If the <c>Id</c> property is null then a new customer record is created, 
		///   otherwise an existing customer with the Id is updated. The following properties 
		///   are ignored: <c>Jobs</c>, <c>Realms</c>, <c>Users</c>.
		/// </remarks>
		/// <param name="customer">The Customer object providing the values to update.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<UpsertResult<Customer>>> UpsertCustomer(Customer customer)
		{
			HttpResponseMessage hrm = await Client.PutAsync("customer/", MakeContent(customer));
			return await UnwrapAndCheckResult<UpsertResult<Customer>>(hrm, throwOnError);
		}

		/// <param name="id">The Id of the customer to validate.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<string[]>> ValidateCustomer(string id)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"customer/validate/{id}");
			return await UnwrapAndCheckResult<string[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Deletes a customer by Id.
		/// </summary>
		/// <remarks>
		///   The response integer is the number of licensing database rows affected by 
		///   delete processing. Zero indicates that the customer was not found.
		/// </remarks>
		/// <param name="id">The Id of the customer to delete.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<int>> DeleteCustomer(string id)
		{
			HttpResponseMessage hrm = await Client.DeleteAsync($"customer/{id}");
			return await UnwrapAndCheckResult<int>(hrm, throwOnError);
		}

		/// <summary>
		///   Reads a customer by Id.
		/// </summary>
		/// <remarks>
		///   The response <c>hasError</c> property will be true if the customer is not 
		///   found.
		/// </remarks>
		/// <param name="id">The Id of the customer to read.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer?>> ReadCustomer(string id)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"customer/read/{id}");
			return await UnwrapAndCheckResult<Customer?>(hrm, throwOnError);
		}

		/// <summary>
		///   Reads customers by Name.
		/// </summary>
		/// <param name="name">The name of the customers to read.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer[]>> ReadCustomersByName(string name)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"customer/read/name/{name}");
			return await UnwrapAndCheckResult<Customer[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a customer from a job.
		/// </summary>
		/// <param name="customerId">The Id of the parent customer.</param>
		/// <param name="jobId">The Id of the child job.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer?>> DisconnectCustomerChildJob(string customerId, string jobId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"customer/disconnect/{customerId}/job/{jobId}");
			return await UnwrapAndCheckResult<Customer?>(hrm, throwOnError);
		}

		/// <summary>
		///   Connect a customer to jobs.
		/// </summary>
		/// <param name="customerId">The parent customer Id.</param>
		/// <param name="jobIds">The child job Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer?>> ConnectCustomerChildJobs(string customerId, string[] jobIds)
		{
			var request = new JoinsRequest(customerId, jobIds);
			HttpResponseMessage hrm = await Client.PostAsync("customer/connect/jobs", MakeContent(request));
			return await UnwrapAndCheckResult<Customer?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces the full set of customer jobs relations.
		/// </summary>
		/// <param name="customerId">The parent customer Id.</param>
		/// <param name="jobIds">The child job Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer?>> ReplaceCustomerChildJobs(string customerId, string[] jobIds)
		{
			var request = new JoinsRequest(customerId, jobIds);
			HttpResponseMessage hrm = await Client.PostAsync("customer/replace/jobs", MakeContent(request));
			return await UnwrapAndCheckResult<Customer?>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a customer from a user.
		/// </summary>
		/// <param name="customerId">The Id of the parent customer.</param>
		/// <param name="userId">The Id of the child user.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer?>> DisconnectCustomerChildUser(string customerId, string userId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"customer/disconnect/{customerId}/user/{userId}");
			return await UnwrapAndCheckResult<Customer?>(hrm, throwOnError);
		}

		/// <summary>
		///   Connect a customer to users.
		/// </summary>
		/// <param name="customerId">The parent customer Id.</param>
		/// <param name="userIds">The child user Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer?>> ConnectCustomerChildUsers(string customerId, string[] userIds)
		{
			var request = new JoinsRequest(customerId, userIds);
			HttpResponseMessage hrm = await Client.PostAsync("customer/connect/users", MakeContent(request));
			return await UnwrapAndCheckResult<Customer?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces the full set of customer to user connections.
		/// </summary>
		/// <param name="customerId">The parent customer Id.</param>
		/// <param name="userIds">The child user Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Customer?>> ReplaceCustomerChildUsers(string customerId, string[] userIds)
		{
			var request = new JoinsRequest(customerId, userIds);
			HttpResponseMessage hrm = await Client.PostAsync("customer/replace/users", MakeContent(request));
			return await UnwrapAndCheckResult<Customer?>(hrm, throwOnError);
		}

		/// <summary>
		///   Lists all Storage Accounts in the Azure Subscription associated with this web 
		///   sersvice.
		/// </summary>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<SubscriptionAccount[]>> ListStorageAccounts()
		{
			HttpResponseMessage hrm = await Client.GetAsync("customer/azure/storage/list");
			return await UnwrapAndCheckResult<SubscriptionAccount[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Checks if a Storage Account name is globally available.
		/// </summary>
		/// <param name="name">The name of the Storage Account to check.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<bool?>> IsStorageAccountNameAvailable(string name)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"customer/azure/storage/available/{name}");
			return await UnwrapAndCheckResult<bool?>(hrm, throwOnError);
		}

		/// <summary>
		///   Creates a Storage Account.
		/// </summary>
		/// <param name="name">The Storage Account name to create.</param>
		/// <param name="resourceGroupName">The resource group name to contain the account.</param>
		/// <param name="location">The location (aka region) can be the short name like 'westus' or the full name like 'West US'.</param>
		/// <param name="allowBlobPublicAccess">True to allow public access to blobs in containers in the account.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<SubscriptionAccount?>> CreateStorageAccount(string name, string resourceGroupName, string location, bool allowBlobPublicAccess)
		{
			var request = new CreateStorageAccountRequest(name, resourceGroupName, location, allowBlobPublicAccess);
			HttpResponseMessage hrm = await Client.PostAsync("customer/azure/storage", MakeContent(request));
			return await UnwrapAndCheckResult<SubscriptionAccount?>(hrm, throwOnError);
		}

		// +----------------------------------+
		// ¦                                  ¦
		// ¦   JobController                  ¦
		// ¦                                  ¦
		// +----------------------------------+

		/// <summary>
		///   Reads a job by Id.
		/// </summary>
		/// <remarks>
		///   The response <c>hasError</c> property will be true if the job is not found.
		/// </remarks>
		/// <param name="id">The Id of the job to read.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Job?>> ReadJob(string id)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"job/read/{id}");
			return await UnwrapAndCheckResult<Job?>(hrm, throwOnError);
		}

		/// <summary>
		///   Lists all jobs.
		/// </summary>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Job[]>> ListJobs()
		{
			HttpResponseMessage hrm = await Client.GetAsync("job/list");
			return await UnwrapAndCheckResult<Job[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Updates or inserts a job.
		/// </summary>
		/// <remarks>
		///   If the <c>Id</c> property is null then a new job record is created, otherwise 
		///   an existing job with the Id is updated. The following properties are ignored: 
		///   <c>Created</c>, <c>Users</c>.
		/// </remarks>
		/// <param name="job">The Job object providing the values to update.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<UpsertResult<Job>>> UpsertJob(Job job)
		{
			HttpResponseMessage hrm = await Client.PutAsync("job/", MakeContent(job));
			return await UnwrapAndCheckResult<UpsertResult<Job>>(hrm, throwOnError);
		}

		/// <param name="id">The Id of the job to validate.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<string[]>> ValidateJob(string id)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"job/validate/{id}");
			return await UnwrapAndCheckResult<string[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Deletes a job by Id.
		/// </summary>
		/// <remarks>
		///   The response integer is the number of licensing database rows affected by 
		///   delete processing. Zero indicates that the job was not found.
		/// </remarks>
		/// <param name="id">The Id of the job to read.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<int>> DeleteJob(string id)
		{
			HttpResponseMessage hrm = await Client.DeleteAsync($"job/{id}");
			return await UnwrapAndCheckResult<int>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a job from a user.
		/// </summary>
		/// <param name="jobId">The Id of the parent job.</param>
		/// <param name="userId">The Id of the child user.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Job?>> DisconnectJobChildUser(string jobId, string userId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"job/disconnect/{jobId}/user/{userId}");
			return await UnwrapAndCheckResult<Job?>(hrm, throwOnError);
		}

		/// <summary>
		///   Connect a job to users.
		/// </summary>
		/// <param name="jobId">The parent job Id.</param>
		/// <param name="userIds">The child user Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Job?>> ConnectJobChildUsers(string jobId, string[] userIds)
		{
			var request = new JoinsRequest(jobId, userIds);
			HttpResponseMessage hrm = await Client.PostAsync("job/connect/users", MakeContent(request));
			return await UnwrapAndCheckResult<Job?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces the full set of job to user connections.
		/// </summary>
		/// <param name="jobId">The parent job Id.</param>
		/// <param name="userIds">The child user Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<Job?>> ReplaceJobChildUsers(string jobId, string[] userIds)
		{
			var request = new JoinsRequest(jobId, userIds);
			HttpResponseMessage hrm = await Client.PostAsync("job/replace/users", MakeContent(request));
			return await UnwrapAndCheckResult<Job?>(hrm, throwOnError);
		}

		/// <summary>
		///   Compares licensing jobs against cloud containers.
		/// </summary>
		/// <returns>
		///   A string of XML describing the differences between licensing and cloud jobs.
		/// </returns>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<string>> CompareJobsAndContainers()
		{
			HttpResponseMessage hrm = await Client.GetAsync("job/compare");
			return await UnwrapAndCheckResult<string>(hrm, throwOnError);
		}

		/// <summary>
		///   Creates a Job Container.
		/// </summary>
		/// <remarks>
		///   Creates an Azure container with a name corresponding to an existing licensing 
		///   job and sets the public access level to Blobs. The container is created in the 
		///   Storage Account that corresponds to the job's parent customer.
		/// </remarks>
		/// <param name="jobId">The job Id of the container to create.</param>
		/// <param name="accessType">Public access level to Blobs in the container.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<bool>> CreateJobContainer(string jobId, JobContainerAccessType accessType)
		{
			var request = new CreateJobContainerRequest(jobId, accessType);
			HttpResponseMessage hrm = await Client.PostAsync("job/azure/container", MakeContent(request));
			return await UnwrapAndCheckResult<bool>(hrm, throwOnError);
		}

		// +----------------------------------+
		// ¦                                  ¦
		// ¦   UserController                 ¦
		// ¦                                  ¦
		// +----------------------------------+

		/// <summary>
		///   Create a user.
		/// </summary>
		/// <remarks>
		///   These properties are ignored because they are internally generated by new user 
		///   processing: <c>Id</c>, <c>Created</c>, <c>PassHash</c>, <c>Uid</c>, 
		///   <c>Customers</c>, <c>Jobs</c>, <c>Realms</c>. All other property values are 
		///   saved in the new user record.
		/// </remarks>
		/// <param name="user">The User containing the values to update.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<UpsertResult<User>>> CreateUser(User user)
		{
			HttpResponseMessage hrm = await Client.PostAsync("user/create", MakeContent(user));
			return await UnwrapAndCheckResult<UpsertResult<User>>(hrm, throwOnError);
		}

		/// <summary>
		///   Reads a user by Id.
		/// </summary>
		/// <remarks>
		///   The response <c>hasError</c> property will be true if the customer is not 
		///   found.
		/// </remarks>
		/// <param name="id">The Id of the user to read.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> ReadUser(string id)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"user/read/{id}");
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Lists all users.
		/// </summary>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User[]>> ListUsers()
		{
			HttpResponseMessage hrm = await Client.GetAsync("user/list");
			return await UnwrapAndCheckResult<User[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Lists all users optionally filtered by realm Ids.
		/// </summary>
		/// <param name="ids">The Ids of the realms to filter the user list response.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User[]>> ListUsers(params string[] ids)
		{
			var request = new IdFilterRequest(ids);
			HttpResponseMessage hrm = await Client.PostAsync("user/list", MakeContent(request));
			return await UnwrapAndCheckResult<User[]>(hrm, throwOnError);
		}

		/// <summary>
		///   List users, optionally filtered by realms.
		/// </summary>
		/// <remarks>
		///   The returned array of lightweight <c>UserPick</c> objects can be used by 
		///   clients to fill summary or pick lists of users.
		/// </remarks>
		/// <param name="ids">Optional realm Ids to filter the user pick list response.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<UserPick[]>> ListUserPicksForRealms(params string[]? ids)
		{
			var request = new IdFilterRequest(ids);
			HttpResponseMessage hrm = await Client.PostAsync("user/list/picks", MakeContent(request));
			return await UnwrapAndCheckResult<UserPick[]>(hrm, throwOnError);
		}

		/// <summary>
		///   Update a user.
		/// </summary>
		/// <remarks>
		///   The <c>Id</c> primary key property identifies the User record to be updated. 
		///   These properties are ignored because they are internally generated by new user 
		///   processing: <c>Created</c>, <c>PassHash</c>, <c>Uid</c>, <c>Customers</c>, 
		///   <c>Jobs</c>, <c>Realms</c>. All other property values are updated in the user 
		///   record.
		/// </remarks>
		/// <param name="user">The User containing the values to update.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<UpsertResult<User>>> UpsertUser(User user)
		{
			HttpResponseMessage hrm = await Client.PutAsync("user/", MakeContent(user));
			return await UnwrapAndCheckResult<UpsertResult<User>>(hrm, throwOnError);
		}

		/// <summary>
		///   Deletes a user by Id.
		/// </summary>
		/// <remarks>
		///   The response integer is the number of licensing database rows affected by 
		///   delete processing. Zero indicates that the user was not found.
		/// </remarks>
		/// <param name="id">The Id of the user to delete.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<int>> DeleteUser(string id)
		{
			HttpResponseMessage hrm = await Client.DeleteAsync($"user/{id}");
			return await UnwrapAndCheckResult<int>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a user from a customer.
		/// </summary>
		/// <param name="userId">The Id of the parent user.</param>
		/// <param name="customerId">The Id of the child customer.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> DisconnectUserChildCustomer(string userId, string customerId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"user/disconnect/{userId}/customer/{customerId}");
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Connects a user to customers.
		/// </summary>
		/// <param name="userId">The parent user Id.</param>
		/// <param name="customerIds">The child customer Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> ConnectUserChildCustomers(string userId, string[] customerIds)
		{
			var request = new JoinsRequest(userId, customerIds);
			HttpResponseMessage hrm = await Client.PostAsync("user/connect/customers", MakeContent(request));
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces user and customer joins.
		/// </summary>
		/// <param name="userId">The parent user Id.</param>
		/// <param name="customerIds">The child customer Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> ReplaceUserChildCustomers(string userId, string[] customerIds)
		{
			var request = new JoinsRequest(userId, customerIds);
			HttpResponseMessage hrm = await Client.PostAsync("user/replace/customers", MakeContent(request));
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a user from a job.
		/// </summary>
		/// <param name="userId">The Id of the parent user.</param>
		/// <param name="jobId">The Id of the child job.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> DisconnectUserChildJob(string userId, string jobId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"user/disconnect/{userId}/job/{jobId}");
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Connects a user to jobs.
		/// </summary>
		/// <param name="userId">The parent user Id.</param>
		/// <param name="jobIds">The child job Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> ConnectUserChildJobs(string userId, string[] jobIds)
		{
			var request = new JoinsRequest(userId, jobIds);
			HttpResponseMessage hrm = await Client.PostAsync("user/connect/jobs", MakeContent(request));
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces user and job joins.
		/// </summary>
		/// <param name="userId">The parent user Id.</param>
		/// <param name="jobIds">The child job Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> ReplaceUserChildJobs(string userId, string[] jobIds)
		{
			var request = new JoinsRequest(userId, jobIds);
			HttpResponseMessage hrm = await Client.PostAsync("user/replace/jobs", MakeContent(request));
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Disconnect a user from a realm.
		/// </summary>
		/// <param name="userId">The Id of the parent user.</param>
		/// <param name="realmId">The Id of the child realm.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> DisconnectUserChildRealm(string userId, string realmId)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"user/disconnect/{userId}/realm/{realmId}");
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   connects a user to realms.
		/// </summary>
		/// <param name="userId">The parent user Id.</param>
		/// <param name="realmIds">The child realm Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> ConnectUserChildRealms(string userId, string[] realmIds)
		{
			var request = new JoinsRequest(userId, realmIds);
			HttpResponseMessage hrm = await Client.PostAsync("user/connect/realms", MakeContent(request));
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Replaces all user to realm connections.
		/// </summary>
		/// <param name="userId">The parent user Id.</param>
		/// <param name="realmIds">The child realm Ids.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<User?>> ReplaceUserChildRealms(string userId, string[] realmIds)
		{
			var request = new JoinsRequest(userId, realmIds);
			HttpResponseMessage hrm = await Client.PostAsync("user/replace/realms", MakeContent(request));
			return await UnwrapAndCheckResult<User?>(hrm, throwOnError);
		}

		/// <summary>
		///   Changes a user's password.
		/// </summary>
		/// <param name="userId">The Id of the User to update.</param>
		/// <param name="oldPassword">The old password.</param>
		/// <param name="newPassword">The new password.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<int>> PasswordChange(string userId, string oldPassword, string newPassword)
		{
			var request = new PasswordChangeRequest(userId, oldPassword, newPassword);
			HttpResponseMessage hrm = await Client.PostAsync("user/password/change", MakeContent(request));
			return await UnwrapAndCheckResult<int>(hrm, throwOnError);
		}

		/// <summary>
		///   Sends a change password request through two-factor-authentication.
		/// </summary>
		/// <remarks>
		///   Attempts to send a change password request via email so it can be verified by 
		///   two-factor-authentication and then processed by an external service.
		/// </remarks>
		/// <param name="userId">The User Id adding a plea to change password.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<string?>> PasswordChangePlea(string userId)
		{
			HttpResponseMessage hrm = await Client.PostAsync("user/plea/password/{userId}", MakeContent(userId));
			return await UnwrapAndCheckResult<string?>(hrm, throwOnError);
		}

		/// <summary>
		///   Gets a plea.
		/// </summary>
		/// <remarks>
		///   Applications can use this endpoint to retreive a previously registered plea, 
		///   validate it, then perform whatever processing is required.
		/// </remarks>
		/// <param name="id">The plea id.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<PleaItem?>> GetPlea(string id)
		{
			HttpResponseMessage hrm = await Client.GetAsync($"user/plea/{id}");
			return await UnwrapAndCheckResult<PleaItem?>(hrm, throwOnError);
		}

		/// <summary>
		///   Updates specific user account values.
		/// </summary>
		/// <param name="userId">The account user Id.</param>
		/// <param name="userName">The new value for the account user name.</param>
		/// <param name="email">The new value for the account email address.</param>
		/// <param name="comment">The new value for the account comment.</param>
		[GeneratedCode("TextTemplatingService", "17.0.0.0")]
		public async Task<ResponseWrap<int>> UpdateAccount(string userId, string userName, string? email, string? comment)
		{
			var request = new UpdateAccountRequest(userId, userName, email, comment);
			HttpResponseMessage hrm = await Client.PutAsync("user/account", MakeContent(request));
			return await UnwrapAndCheckResult<int>(hrm, throwOnError);
		}

	}
}
